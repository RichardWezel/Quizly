Am 5. Mai haben wir die erste Version der Event-Sourcing die W vorgestellt. Das ist gerade einmal vier Monate her und seitdem ist unglaublich viel passiert. Allein von Docker Hub wurde die Datenbank bereits über 6000 Mal heruntergeladen und das sind nur die Container Download. Die direkten Beinery Downloads sind da noch gar nicht mitgezählt. Das ist ein großartiger Start. Auch die kleinen SDKs entwickeln sich fantastisch. So verzeichnet beispielsweise das top net client SDK schon über 3.100 Downloads. Node.js liegt bei mehr als 2.100 Downloads rust bei über 1600. Und das sind nur die top drei. Zusätzlich gibt es auch noch offizielle SDKs für Go, für Python und für PHP. Und für alle die auf Basis der JVM entwickeln steht mit OpenCQS inzwischen sogar ein erstes komplettes Anwendungs-Fraindwerk zur Verfügung. Das auf der Event-Sourcing DB basiert und das schon fast 50 Sterne aufgetabt hat. Aber noch wichtiger als die Zahlen ist das Feedback. Die Rückmeldungen sind durchweg positiv. Immer wieder hören wir die gleichen Stichworte, Einfachheit, Klarheit, Frischer Wind. Genau dafür haben wir die Event-Sourcing DB entwickelt, damit du dich auf die Fachlichkeit konzentrieren kannst während die Datenbank das verlässliche Fundament im Hintergrund bildet. Das ist der aktuelle Stand. Und heute gehen wir einen Schritt weiter. Heute stelle ich dir nämlich Version 1.1 vor. Das heißt es gibt ein paar wirklich spannende Neuigkeiten für dich. Es geht um Konsistenz, es geht um Sicherheit, es geht um Compliance und es geht um viele kleine Detailverbesserungen die deinen Alltag noch effizienter machen. Und am Ende habe ich noch eine Sache die ich dir unbedingt erzählen muss. Ein ganz zentrales Thema in Event-Sourcing ist immer wieder die Frage wie schneide ich Aggregates und die ehrliche Antwort lautet, es ist unglaublich schwer das richtig zu machen. Sehr oft ist das sehr viel schwerer als man zunächst einmal glaubt. Manchmal passt ein Aggregate perfekt, aber sehr oft da passt es eben auch nicht. Und wenn man einmal falsch geschnitten hat, dann merkt man das häufig erst sehr viel später. Doch dann ist der Fehler oft kaum noch zu korrigieren und das ist ein echtes Problem in der Praxis. Und genau hier kommen Dynamic Consistency Boundaries kurz DCBs ins Spiel. Sie geben dir nämlich eine Alternative. Statt zu versuchen, Aggregates so lange zu modellieren bis sie irgendwie passen kannst du mit DCBs deine Konsistenzgrenzen dynamisch beschreiben. So kannst du einfach definieren wo tatsächlich strikte Konsistenz erforderlich ist und wo Eventual-Konsistenz sie völlig ausreicht. Wir haben dazu vor ein paar Wochen schon ein Video gemacht und wenn du tiefer in das ganze Konzept der DCBs einsteigen möchtest, dann schau dir dieses Video unbedingt noch einmal an. Den Link dorthin den findest du wie immer hier oben in der Infokart. Aber heute geht es um die Frage wie setzen wir das in der Event-Sourcing die B um. Und die Antwort lautet Version 1.1 unterstützt Dynamic Consistency Boundaries jetzt vollumfanglich. Wir haben dazu eine neue prekondischen eingeführt mit der du eine eventkuelle Abfrage definieren kannst die vor dem Schreiben von Events ausgeführt wird und nur wenn diese Abfrage den gewünschten Wert liefert werden die Events auch tatsächlich gespeichert und das Beste daran diese Umsetzung ist keine pro prieteere Lösung sondern vollständig conform zur offiziellen Spezifikation für Dynamic Consistency Boundaries. Das heißt du kannst dich darauf verlassen dass das Verhalten der Event-Sourcing die B standardisiert ist und mit anderen Implementierungen nahtlos zusammenpasst. Und damit hast du jetzt die Wahl. Wenn es auf maximale Performance ankommt dann arbeitest du weiterhin subject passiert. Wenn es aber auf maximale Flexibilität ankommt dann nutzt du diese neue prekondischen. Du kannst in jedem Scenario freie entscheiden Ad hoc was für dich besser passt. Das ist ein riesiger Schritt nach vorne denn er löst ein Problem mit dem sehr viele Teams in der Praxis jeden Tag immer wieder zu kämpfen haben und er macht die Event-Sourcing B noch flexibler ohne dass du Kompromisse eingehen musst. Ein zweiter ganz großer Schritt in Version 1.1 sind signierte Events. Event sind das Fundament deiner Anwendung. Das heißt sie müssen vor allem anderen Vertrauen zuirdik sein. Sie müssen Integrität garantieren und sie müssen sich jederzeit verifizieren lassen. Und bislang war das schon stark gelöst denn jedes Event wird gehescht und die Hashes werden miteinander verkettet. Ganz ähnlich wie bei einer Blockchain. Das bedeutet wenn ein einziges Event verändert würde würde die ganze Kette in Valide werden und brechen. Das gibt dir schon sehr viel Sicherheit aber für viele Scenario in Genüpters nicht. Gerade wenn es um Compliance geht im Finanzwesen, im Gesundheitswesen, im öffentlichen Sektor. Dort braucht du noch einen zusätzlichen Vertrauensanker und genau den liefern wir jetzt. Mit Version 1.1 kannst du deine Events nämlich digital signieren. Wir setzen dabei auf das ED25519 Verfahren also auf einen bewährten, sicheren und modernen Algorithmus der quasi als Industriestandard gilt. Du aktivierst das ganze ganz einfach über einen Kommando-Zahlenflack und ab diesem Moment passiert alles weitere Automatisch. Sei es beim Schreiben, beim Lesen oder beim Abonnieren von Events. Jedes Event hält eine digitale Signature und das wirklich spannender daran, diese Signature, die wird nicht gespeichert, sondern sie wird jedes Mal neu berechnet und warum ist das so wichtig? Ganz einfach, weil du damit jederzeit deinen Schlüssel wechseln kannst, ohne dass du deine Events nachträglich anpassen müsstest. Das heißt, die Events bleiben unverändert, aber die Signaturen bleiben trotzdem überprüfbar auch langfristig. Und natürlich haben wir auch an die Verifikation des ganzen gedacht, du kannst Signaturen mit den kleinen SDKs überprüfen, inklusive Hescheüberprüfungen. Aktuell funktioniert das schon für Go und Jarviscript, die anderen SDKs folgen in Kürze und das Ergebnis, du hast jederzeit die Gewissheit, dass deine Events echt und unverändert sind. Und du kannst das gegenüber Auditorinnen, Compliance Teams oder Regulatoren belegen. Das ist ein riesiger Schritt an Vertrauen und an Sicherheit. Neben diesen großen Features haben wir in Version 1.1 aber auch an den Details gearbeitet und manchmal sind es gerade die kleinen Dinge, die den größten Unterschied machen. Ein Beispiel ist der EventQL-Editor. Bislang musst du es so zum Beispiel die Eventtypen kennen oder nachschauen. Jetzt schlägt dir der Editor automatisch passende Eventtypen vor, während du tippst, das schwarzzeit, das reduziert Tippfehler und es macht die Arbeit am Ende vor allem einfach flüssiger. Wir haben auch die API weiter. So gibt es zum Beispiel einen neuen Endpunkt, mit dem du gezielt die Informationen zu einem einzelnen Eventtyp abfragen kannst und nicht wie bisher immer nur für alle. Und wir haben bestehende Endpunkte überarbeitet, so dass sie sich Konsistenter verhalten. Alles fühlt sich dadurch ein Stück elegant an. Auch die Management UI ist besser geworden. Das Leitthem verhält sich jetzt so wie man es erwartet und insgesamt wirkt die Oberfläche stabiler, runter und dreiefer. Und natürlich haben wir an vielen Stellen auch im Hintergrund optimiert, ein paar Fehlerbehoben und viele Kleinigkeiten für besser. Version 1.0 war bereits sehr stabil, aber mit Version 1.1 fühlt sich das Arbeiten mit der Event-Sourcing-DB einfach noch ein bisschen angenehm an. Eine Sache noch, ab sofort gibt es die Event-Sourcing-DB nicht nur als on-premise-Lösung, sondern auch als Managed-Version. Das bedeutet, du musst dich nicht mehr selbst um den Betrieb kümmern. Kein Z-App mehr, kein Monitoring, keine Updates, keine Back-ups. Wir übernehmen das alles für dich. Und diese Managed-Version startet heute und zwar in einer Private Beta. Wenn du dabei sein möchtest, dann schreib uns einfach eine kurze E-Mail an Hello at theNateFab.io. Wir führen eine Warteliste und wir schalten danach und nach in Badges frei. Damit erfüllen wir einen Wunsch, den wir sehr oft gehört haben in den vergangenen Monaten. Nämlich, wir möchten die Event-Sourcing-DB gerne nutzen, aber wir wollen sie nicht selbst betreiben. Genau dafür ist die Managed-Version gedacht. Und das kommt aber noch besser. Denn bislang war die Event-Sourcing-DB ganz klar ausschließlich auf den Enterprise-Markt ausgerichtet, eben als on-premise-Lösung. Und das bleibt auch so, aber mit der Managed-Version öffnen wir eine neue Tür. Wir bieten nämlich darüber hinaus ein zusätzliches neues Preismodell an, das nicht nur für große Unternehmen geeignet ist, sondern auch für einzelne Entwicklerinnen und Entwickler, für Start-ups und für kleine Teams. Und damit machen wir die Event-Sourcing-DB für eine viel breite Zielgruppe zugänglich. Unsere Enterprise-Kunden bekommen weiterhin die volle Power wie bisher, aber zusätzlich können jetzt eben auch kleine Organisationen starten, ohne die Hürde Infrastruktur selbst aufsetzen und betreiben zu müssen. Die Private Beta ist ab sofort verfügbar und die ersten Plätze gehen an diejenigen, die sich als erste melden. Und damit sind wir am Ende angekommen und fassen wir das Ganze noch mal zusammen. Mit Version 1.1 bringen wir also die volle Unterstützung für Dynamic Consistency-Boundaries. Auf der Basis unserer bewerten Abfrage sprache eventkuell mit einer neuen Prekondition conform zur offiziellen Spezifikation. Das gibt dir die Freiheit, genau zu entscheiden, wie viel Konsistenz du wann brauchst. Wir haben signierte Events eingeführt, mit ED25519, mit on the Fly-Signaturen und mit Verifikation über die Client SDKs. Das hebt die Sicherheit und auch die Compliance auf ein ganz neues Level. Wir haben außerdem die Developer Experience verbessert, Auto-Complete im Eventkuell-Editor, neue und überarbeitete API-Entpunkte und eine UI, die stabiler und runderwirkt. Viele kleine Optimierungen, die alles insgesamt einfach smudernachen. Und zu guter Letzt haben wir die Managed-Version vorgestellt, ab sofort als Private Beta mit einer Warte-Liste und mit einem neuen Preismodell, das Event-Sourcing-DB auch für einzelne Entwicklerinnen und Entwickler, für Start-ups und für kleine Teams zugänglich macht. Die neue Version steht ab sofort zum Download bereit. Du kannst sie direkt jetzt nach dem Video vom Docker Hub herunterladen oder von der Webseite als Beine-Rea für verschiedene Plattformen. Und du kannst sie in praktisch jedem Tech-Stack einsetzen, mit SDKs für Go, für JavaScript, für TypeScript, für DopNet, für PHP, für Python, für Rust und für die JVM. Probier die neue Version jetzt aus und ich wünsche dir dabei sehr viel Spaß und vor allem natürlich sehr viel Erfolg. Alles Gute!